//! 路由注册系统，用于收集和管理所有使用uni_routing宏定义的路由

use std::sync::{Arc, Mutex};
use crate::routing::{RouteInfo, HttpMethod};

/// 路由注册表，存储所有已注册的路由
pub struct RouteRegistry {
    routes: Arc<Mutex<Vec<RouteInfo>>>,
}

impl RouteRegistry {
    /// 创建新的路由注册表
    pub fn new() -> Self {
        Self {
            routes: Arc::new(Mutex::new(Vec::new())),
        }
    }

    /// 注册单个路由
    pub fn register_route(&self, route: RouteInfo) {
        let mut routes = self.routes.lock().unwrap();
        routes.push(route);
    }

    /// 获取所有路由
    pub fn get_routes(&self) -> Vec<RouteInfo> {
        let routes = self.routes.lock().unwrap();
        routes.clone()
    }

    /// 根据路径和方法获取路由
    pub fn get_route(&self, path: &str, method: HttpMethod) -> Option<RouteInfo> {
        let routes = self.routes.lock().unwrap();
        routes.iter()
            .find(|r| r.path == path && r.method == method)
            .cloned()
    }

    /// 生成OpenAPI规范
    pub fn generate_openapi(&self, title: &str, version: &str) -> serde_json::Value {
        let routes = self.get_routes();
        let mut paths = serde_json::Map::new();

        for route in routes {
            let path_item = self.create_path_item(&route);
            paths.insert(route.path.clone(), serde_json::Value::Object(path_item));
        }

        serde_json::json!({
            "openapi": "3.0.0",
            "info": {
                "title": title,
                "version": version,
                "description": "API documentation generated by uni_routing"
            },
            "paths": serde_json::Value::Object(paths),
            "components": {
                "securitySchemes": {
                    "bearerAuth": {
                        "type": "http",
                        "scheme": "bearer",
                        "bearerFormat": "JWT"
                    }
                }
            }
        })
    }

    /// 创建路径项
    fn create_path_item(&self, route: &RouteInfo) -> serde_json::Map<String, serde_json::Value> {
        let mut path_item = serde_json::Map::new();
        let method_str = match route.method {
            HttpMethod::GET => "get",
            HttpMethod::POST => "post",
            HttpMethod::PUT => "put",
            HttpMethod::DELETE => "delete",
            HttpMethod::PATCH => "patch",
        };

        let mut operation = serde_json::Map::new();
        operation.insert("summary".to_string(), serde_json::Value::String(
            route.description.clone().unwrap_or_else(|| "API endpoint".to_string())
        ));

        if route.description.is_some() {
            operation.insert("description".to_string(), serde_json::Value::String(
                route.description.clone().unwrap()
            ));
        }

        // 添加认证要求
        if route.auth_policy.is_some() {
            operation.insert("security".to_string(), serde_json::json!([{"bearerAuth": []}]));
        }

        // 添加响应
        let mut responses = serde_json::Map::new();
        responses.insert("200".to_string(), serde_json::json!({
            "description": "Successful response"
        }));
        operation.insert("responses".to_string(), serde_json::Value::Object(responses));

        path_item.insert(method_str.to_string(), serde_json::Value::Object(operation));
        path_item
    }
}

impl Default for RouteRegistry {
    fn default() -> Self {
        Self::new()
    }
}

/// 全局路由注册表实例
static mut GLOBAL_REGISTRY: Option<RouteRegistry> = None;
static INIT: std::sync::Once = std::sync::Once::new();

/// 获取全局路由注册表
pub fn get_global_registry() -> &'static RouteRegistry {
    unsafe {
        INIT.call_once(|| {
            GLOBAL_REGISTRY = Some(RouteRegistry::new());
        });
        GLOBAL_REGISTRY.as_ref().unwrap()
    }
}

/// 宏辅助函数，用于注册路由
pub fn register_route(route: RouteInfo) {
    get_global_registry().register_route(route);
}

/// 获取所有已注册的路由
pub fn get_all_routes() -> Vec<RouteInfo> {
    get_global_registry().get_routes()
}

/// 生成完整的OpenAPI文档
pub fn generate_openapi_docs(title: &str, version: &str) -> serde_json::Value {
    get_global_registry().generate_openapi(title, version)
}